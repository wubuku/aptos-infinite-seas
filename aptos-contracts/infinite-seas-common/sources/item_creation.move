// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_seas_common::item_creation {
    use aptos_framework::account;
    use aptos_framework::event;
    use aptos_std::table::{Self, Table};
    use infinite_seas_common::infinite_seas_common_pass_object as pass_object;
    use infinite_seas_common::skill_type_item_id_pair::SkillTypeItemIdPair;
    friend infinite_seas_common::item_creation_create_logic;
    friend infinite_seas_common::item_creation_update_logic;
    friend infinite_seas_common::item_creation_aggregate;

    const EIdAlreadyExists: u64 = 101;
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const ENotInitialized: u64 = 110;

    struct Events has key {
        item_creation_created_handle: event::EventHandle<ItemCreationCreated>,
        item_creation_updated_handle: event::EventHandle<ItemCreationUpdated>,
    }

    struct Tables has key {
        item_creation_table: Table<SkillTypeItemIdPair, ItemCreation>,
    }

    public fun initialize(store_account: &signer) {
        move_to(store_account, Events {
            item_creation_created_handle: account::new_event_handle<ItemCreationCreated>(store_account),
            item_creation_updated_handle: account::new_event_handle<ItemCreationUpdated>(store_account),
        });

        move_to(
            store_account,
            Tables {
                item_creation_table: table::new(),
            },
        );

    }

    struct ItemCreation has store {
        item_creation_id: SkillTypeItemIdPair,
        version: u64,
        resource_cost: u32,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    }

    public fun item_creation_id(item_creation: &ItemCreation): SkillTypeItemIdPair {
        item_creation.item_creation_id
    }

    public fun version(item_creation: &ItemCreation): u64 {
        item_creation.version
    }

    public fun resource_cost(item_creation: &ItemCreation): u32 {
        item_creation.resource_cost
    }

    public(friend) fun set_resource_cost(item_creation: &mut ItemCreation, resource_cost: u32) {
        item_creation.resource_cost = resource_cost;
    }

    public fun requirements_level(item_creation: &ItemCreation): u16 {
        item_creation.requirements_level
    }

    public(friend) fun set_requirements_level(item_creation: &mut ItemCreation, requirements_level: u16) {
        item_creation.requirements_level = requirements_level;
    }

    public fun base_quantity(item_creation: &ItemCreation): u32 {
        item_creation.base_quantity
    }

    public(friend) fun set_base_quantity(item_creation: &mut ItemCreation, base_quantity: u32) {
        item_creation.base_quantity = base_quantity;
    }

    public fun base_experience(item_creation: &ItemCreation): u32 {
        item_creation.base_experience
    }

    public(friend) fun set_base_experience(item_creation: &mut ItemCreation, base_experience: u32) {
        item_creation.base_experience = base_experience;
    }

    public fun base_creation_time(item_creation: &ItemCreation): u64 {
        item_creation.base_creation_time
    }

    public(friend) fun set_base_creation_time(item_creation: &mut ItemCreation, base_creation_time: u64) {
        item_creation.base_creation_time = base_creation_time;
    }

    public fun energy_cost(item_creation: &ItemCreation): u64 {
        item_creation.energy_cost
    }

    public(friend) fun set_energy_cost(item_creation: &mut ItemCreation, energy_cost: u64) {
        item_creation.energy_cost = energy_cost;
    }

    public fun success_rate(item_creation: &ItemCreation): u16 {
        item_creation.success_rate
    }

    public(friend) fun set_success_rate(item_creation: &mut ItemCreation, success_rate: u16) {
        item_creation.success_rate = success_rate;
    }

    fun new_item_creation(
        item_creation_id: SkillTypeItemIdPair,
        resource_cost: u32,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    ): ItemCreation {
        ItemCreation {
            item_creation_id,
            version: 0,
            resource_cost,
            requirements_level,
            base_quantity,
            base_experience,
            base_creation_time,
            energy_cost,
            success_rate,
        }
    }

    struct ItemCreationCreated has store, drop {
        item_creation_id: SkillTypeItemIdPair,
        resource_cost: u32,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    }

    public fun item_creation_created_item_creation_id(item_creation_created: &ItemCreationCreated): SkillTypeItemIdPair {
        item_creation_created.item_creation_id
    }

    public fun item_creation_created_resource_cost(item_creation_created: &ItemCreationCreated): u32 {
        item_creation_created.resource_cost
    }

    public fun item_creation_created_requirements_level(item_creation_created: &ItemCreationCreated): u16 {
        item_creation_created.requirements_level
    }

    public fun item_creation_created_base_quantity(item_creation_created: &ItemCreationCreated): u32 {
        item_creation_created.base_quantity
    }

    public fun item_creation_created_base_experience(item_creation_created: &ItemCreationCreated): u32 {
        item_creation_created.base_experience
    }

    public fun item_creation_created_base_creation_time(item_creation_created: &ItemCreationCreated): u64 {
        item_creation_created.base_creation_time
    }

    public fun item_creation_created_energy_cost(item_creation_created: &ItemCreationCreated): u64 {
        item_creation_created.energy_cost
    }

    public fun item_creation_created_success_rate(item_creation_created: &ItemCreationCreated): u16 {
        item_creation_created.success_rate
    }

    public(friend) fun new_item_creation_created(
        item_creation_id: SkillTypeItemIdPair,
        resource_cost: u32,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    ): ItemCreationCreated {
        ItemCreationCreated {
            item_creation_id,
            resource_cost,
            requirements_level,
            base_quantity,
            base_experience,
            base_creation_time,
            energy_cost,
            success_rate,
        }
    }

    struct ItemCreationUpdated has store, drop {
        item_creation_id: SkillTypeItemIdPair,
        version: u64,
        resource_cost: u32,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    }

    public fun item_creation_updated_item_creation_id(item_creation_updated: &ItemCreationUpdated): SkillTypeItemIdPair {
        item_creation_updated.item_creation_id
    }

    public fun item_creation_updated_resource_cost(item_creation_updated: &ItemCreationUpdated): u32 {
        item_creation_updated.resource_cost
    }

    public fun item_creation_updated_requirements_level(item_creation_updated: &ItemCreationUpdated): u16 {
        item_creation_updated.requirements_level
    }

    public fun item_creation_updated_base_quantity(item_creation_updated: &ItemCreationUpdated): u32 {
        item_creation_updated.base_quantity
    }

    public fun item_creation_updated_base_experience(item_creation_updated: &ItemCreationUpdated): u32 {
        item_creation_updated.base_experience
    }

    public fun item_creation_updated_base_creation_time(item_creation_updated: &ItemCreationUpdated): u64 {
        item_creation_updated.base_creation_time
    }

    public fun item_creation_updated_energy_cost(item_creation_updated: &ItemCreationUpdated): u64 {
        item_creation_updated.energy_cost
    }

    public fun item_creation_updated_success_rate(item_creation_updated: &ItemCreationUpdated): u16 {
        item_creation_updated.success_rate
    }

    public(friend) fun new_item_creation_updated(
        item_creation: &ItemCreation,
        resource_cost: u32,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    ): ItemCreationUpdated {
        ItemCreationUpdated {
            item_creation_id: item_creation_id(item_creation),
            version: version(item_creation),
            resource_cost,
            requirements_level,
            base_quantity,
            base_experience,
            base_creation_time,
            energy_cost,
            success_rate,
        }
    }


    public(friend) fun create_item_creation(
        store_address: address,
        item_creation_id: SkillTypeItemIdPair,
        resource_cost: u32,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    ): ItemCreation acquires Tables {
        asset_item_creation_not_exists(store_address, item_creation_id);
        let item_creation = new_item_creation(
            item_creation_id,
            resource_cost,
            requirements_level,
            base_quantity,
            base_experience,
            base_creation_time,
            energy_cost,
            success_rate,
        );
        item_creation
    }

    public(friend) fun asset_item_creation_not_exists(
        store_address: address, item_creation_id: SkillTypeItemIdPair,
    ) acquires Tables {
        assert!(exists<Tables>(store_address), ENotInitialized);
        let tables = borrow_global_mut<Tables>(store_address);
        assert!(!table::contains(&tables.item_creation_table, item_creation_id), EIdAlreadyExists);
    }

    public(friend) fun update_version_and_add(store_address: address, item_creation: ItemCreation) acquires Tables {
        item_creation.version = item_creation.version + 1;
        //assert!(item_creation.version != 0, EInappropriateVersion);
        private_add_item_creation(store_address, item_creation);
    }

    public(friend) fun add_item_creation(store_address: address, item_creation: ItemCreation) acquires Tables {
        assert!(item_creation.version == 0, EInappropriateVersion);
        private_add_item_creation(store_address, item_creation);
    }

    public(friend) fun remove_item_creation(store_address: address, item_creation_id: SkillTypeItemIdPair): ItemCreation acquires Tables {
        assert!(exists<Tables>(store_address), ENotInitialized);
        let tables = borrow_global_mut<Tables>(store_address);
        table::remove(&mut tables.item_creation_table, item_creation_id)
    }

    fun private_add_item_creation(store_address: address, item_creation: ItemCreation) acquires Tables {
        assert!(exists<Tables>(store_address), ENotInitialized);
        let tables = borrow_global_mut<Tables>(store_address);
        table::add(&mut tables.item_creation_table, item_creation.item_creation_id, item_creation);
    }

    public fun get_item_creation(store_address: address, item_creation_id: SkillTypeItemIdPair): pass_object::PassObject<ItemCreation> acquires Tables {
        let item_creation = remove_item_creation(store_address, item_creation_id);
        pass_object::new_with_address(item_creation, store_address, )
    }

    public fun return_item_creation(item_creation_pass_obj: pass_object::PassObject<ItemCreation>) acquires Tables {
        let (item_creation, store_address, ) = pass_object::extract_value_and_address(item_creation_pass_obj);
        private_add_item_creation(store_address, item_creation);
    }

    public(friend) fun borrow(item_creation_pass_obj: &pass_object::PassObject<ItemCreation>): &ItemCreation {
        pass_object::borrow(item_creation_pass_obj)
    }

    public(friend) fun borrow_mut(item_creation_pass_obj: &mut pass_object::PassObject<ItemCreation>): &mut ItemCreation {
        pass_object::borrow_mut(item_creation_pass_obj)
    }

    public(friend) fun drop_item_creation(item_creation: ItemCreation) {
        let ItemCreation {
            version: _version,
            item_creation_id: _item_creation_id,
            resource_cost: _resource_cost,
            requirements_level: _requirements_level,
            base_quantity: _base_quantity,
            base_experience: _base_experience,
            base_creation_time: _base_creation_time,
            energy_cost: _energy_cost,
            success_rate: _success_rate,
        } = item_creation;
    }

    public fun contains_item_creation(store_address: address, item_creation_id: SkillTypeItemIdPair): bool acquires Tables {
        let tables = borrow_global<Tables>(store_address);
        table::contains(&tables.item_creation_table, item_creation_id)
    }

    public(friend) fun emit_item_creation_created(store_address: address, item_creation_created: ItemCreationCreated) acquires Events {
        assert!(exists<Events>(store_address), ENotInitialized);
        let events = borrow_global_mut<Events>(store_address);
        event::emit_event(&mut events.item_creation_created_handle, item_creation_created);
    }

    public(friend) fun emit_item_creation_updated(store_address: address, item_creation_updated: ItemCreationUpdated) acquires Events {
        assert!(exists<Events>(store_address), ENotInitialized);
        let events = borrow_global_mut<Events>(store_address);
        event::emit_event(&mut events.item_creation_updated_handle, item_creation_updated);
    }

}
