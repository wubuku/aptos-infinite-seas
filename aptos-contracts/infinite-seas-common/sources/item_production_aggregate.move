// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_seas_common::item_production_aggregate {
    use infinite_seas_common::item_id_quantity_pairs::{Self, ItemIdQuantityPairs};
    use infinite_seas_common::item_production;
    use infinite_seas_common::item_production_create_logic;
    use infinite_seas_common::item_production_update_logic;
    use infinite_seas_common::skill_type_item_id_pair::{Self, SkillTypeItemIdPair};

    const ENotPublisher: u64 = 50;

    public entry fun create(
        account: &signer,
        store_address: address,
        item_production_id_skill_type: u8,
        item_production_id_item_id: u32,
        production_materials_item_id_list: vector<u32>,
        production_materials_item_quantity_list: vector<u32>,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    ) {
        assert!(std::signer::address_of(account) == @infinite_seas_common, ENotPublisher);
        let item_production_id: SkillTypeItemIdPair = skill_type_item_id_pair::new(
            item_production_id_skill_type,
            item_production_id_item_id,
        );

        let production_materials: ItemIdQuantityPairs = item_id_quantity_pairs::new(
            production_materials_item_id_list,
            production_materials_item_quantity_list,
        );
        let item_production_created = item_production_create_logic::verify(
            account,
            store_address,
            item_production_id,
            production_materials,
            requirements_level,
            base_quantity,
            base_experience,
            base_creation_time,
            energy_cost,
            success_rate,
        );
        let item_production = item_production_create_logic::mutate(
            account,
            store_address,
            &item_production_created,
        );
        item_production::add_item_production(store_address, item_production);
        item_production::emit_item_production_created(store_address, item_production_created);
    }

    public entry fun update(
        account: &signer,
        store_address: address,
        item_production_id_skill_type: u8,
        item_production_id_item_id: u32,
        production_materials_item_id_list: vector<u32>,
        production_materials_item_quantity_list: vector<u32>,
        requirements_level: u16,
        base_quantity: u32,
        base_experience: u32,
        base_creation_time: u64,
        energy_cost: u64,
        success_rate: u16,
    ) {
        assert!(std::signer::address_of(account) == @infinite_seas_common, ENotPublisher);
        let item_production_id: SkillTypeItemIdPair = skill_type_item_id_pair::new(
            item_production_id_skill_type,
            item_production_id_item_id,
        );

        let production_materials: ItemIdQuantityPairs = item_id_quantity_pairs::new(
            production_materials_item_id_list,
            production_materials_item_quantity_list,
        );
        let item_production = item_production::remove_item_production(store_address, item_production_id);
        let item_production_updated = item_production_update_logic::verify(
            account,
            store_address,
            production_materials,
            requirements_level,
            base_quantity,
            base_experience,
            base_creation_time,
            energy_cost,
            success_rate,
            &item_production,
        );
        let updated_item_production = item_production_update_logic::mutate(
            account,
            store_address,
            &item_production_updated,
            item_production,
        );
        item_production::update_version_and_add(store_address, updated_item_production);
        item_production::emit_item_production_updated(store_address, item_production_updated);
    }

}
