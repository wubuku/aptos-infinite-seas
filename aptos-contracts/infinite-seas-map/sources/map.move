// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_seas_map::map {
    use aptos_framework::account;
    use aptos_framework::event;
    use aptos_std::table_with_length::{Self, TableWithLength};
    use infinite_seas_common::coordinates::Coordinates;
    use infinite_seas_common::item_id_quantity_pair::ItemIdQuantityPair;
    use infinite_seas_common::item_id_quantity_pairs::ItemIdQuantityPairs;
    use infinite_seas_map::infinite_seas_map_pass_object as pass_object;
    use infinite_seas_map::map_location::{Self, MapLocation};
    friend infinite_seas_map::map_add_island_logic;
    friend infinite_seas_map::map_claim_island_logic;
    friend infinite_seas_map::map_gather_island_resources_logic;
    friend infinite_seas_map::map_aggregate;

    const EIdAlreadyExists: u64 = 101;
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const ENotInitialized: u64 = 110;
    const EIdNotFound: u64 = 111;
    const EMismatchedStoreAddress: u64 = 112;

    struct Events has key {
        island_added_handle: event::EventHandle<IslandAdded>,
        map_island_claimed_handle: event::EventHandle<MapIslandClaimed>,
        island_resources_gathered_handle: event::EventHandle<IslandResourcesGathered>,
        map_location_table_item_added_handle: event::EventHandle<MapLocationTableItemAdded>,
    }

    struct MapLocationTableItemAdded has store, drop {
        coordinates: Coordinates,
    }

    fun emit_map_location_table_item_added(store_address: address, table_item_added: MapLocationTableItemAdded) acquires Events {
        assert!(exists<Events>(store_address), ENotInitialized);
        let events = borrow_global_mut<Events>(store_address);
        event::emit_event(&mut events.map_location_table_item_added_handle, table_item_added);
    }

    public fun initialize(store_account: &signer) {
        move_to(store_account, Events {
            island_added_handle: account::new_event_handle<IslandAdded>(store_account),
            map_island_claimed_handle: account::new_event_handle<MapIslandClaimed>(store_account),
            island_resources_gathered_handle: account::new_event_handle<IslandResourcesGathered>(store_account),
            map_location_table_item_added_handle: account::new_event_handle<MapLocationTableItemAdded>(store_account),
        });

        let map = new_map();
        add_map(store_account, map);
    }

    struct Map has key, store {
        version: u64,
        locations: TableWithLength<Coordinates, MapLocation>,
    }

    public fun version(map: &Map): u64 {
        map.version
    }

    public(friend) fun add_location(store_address: address, map: &mut Map, location: MapLocation) acquires Events {
        let coordinates = map_location::coordinates(&location);
        assert!(!table_with_length::contains(&map.locations, coordinates), EIdAlreadyExists);
        table_with_length::add(&mut map.locations, coordinates, location);
        emit_map_location_table_item_added(store_address, MapLocationTableItemAdded {
            coordinates,
        });
    }

    public(friend) fun singleton_add_location(store_address: address, location: MapLocation) acquires Map, Events {
        let map = borrow_global_mut<Map>(store_address, );
        add_location(store_address, map, location)
    }

    public(friend) fun remove_location(map: &mut Map, coordinates: Coordinates): MapLocation {
        assert!(table_with_length::contains(&map.locations, coordinates), EIdNotFound);
        table_with_length::remove(&mut map.locations, coordinates)
    }

    public(friend) fun remove_and_drop_location(map: &mut Map, coordinates: Coordinates) {
        let location = remove_location(map, coordinates);
        map_location::drop_map_location(location);
    }

    public(friend) fun singleton_remove_location(store_address: address, coordinates: Coordinates): MapLocation acquires Map {
        let map = borrow_global_mut<Map>(store_address, );
        remove_location(map, coordinates)
    }


    public(friend) fun borrow_mut_location(map: &mut Map, coordinates: Coordinates): &mut MapLocation {
        table_with_length::borrow_mut(&mut map.locations, coordinates)
    }

    public fun borrow_location(map: &Map, coordinates: Coordinates): &MapLocation {
        table_with_length::borrow(&map.locations, coordinates)
    }

    public fun locations_contains(map: &Map, coordinates: Coordinates): bool {
        table_with_length::contains(&map.locations, coordinates)
    }

    public fun singleton_locations_contains(store_address: address, coordinates: Coordinates): bool acquires Map {
        let map = borrow_global<Map>(store_address, );
        locations_contains(map, coordinates)
    }

    public fun locations_length(map: &Map): u64 {
        table_with_length::length(&map.locations)
    }

    public fun singleton_locations_length(store_address: address, ): u64 acquires Map {
        let map = borrow_global<Map>(store_address, );
        locations_length(map)
    }

    public(friend) fun new_map(
    ): Map {
        Map {
            version: 0,
            locations: table_with_length::new<Coordinates, MapLocation>(),
        }
    }

    struct MapInitialized has store, drop {
    }

    public(friend) fun new_map_initialized(
        map: &Map,
    ): MapInitialized {
        MapInitialized {
        }
    }

    struct IslandAdded has store, drop {
        version: u64,
        coordinates: Coordinates,
        resources: ItemIdQuantityPairs,
    }

    public fun island_added_coordinates(island_added: &IslandAdded): Coordinates {
        island_added.coordinates
    }

    public fun island_added_resources(island_added: &IslandAdded): ItemIdQuantityPairs {
        island_added.resources
    }

    public(friend) fun new_island_added(
        store_address: address,
        coordinates: Coordinates,
        resources: ItemIdQuantityPairs,
    ): IslandAdded acquires Map {
        IslandAdded {
            version: singleton_version(store_address, ),
            coordinates,
            resources,
        }
    }

    struct MapIslandClaimed has store, drop {
        version: u64,
        coordinates: Coordinates,
        claimed_by: address,
        claimed_at: u64,
    }

    public fun map_island_claimed_coordinates(map_island_claimed: &MapIslandClaimed): Coordinates {
        map_island_claimed.coordinates
    }

    public fun map_island_claimed_claimed_by(map_island_claimed: &MapIslandClaimed): address {
        map_island_claimed.claimed_by
    }

    public fun map_island_claimed_claimed_at(map_island_claimed: &MapIslandClaimed): u64 {
        map_island_claimed.claimed_at
    }

    public(friend) fun new_map_island_claimed(
        store_address: address,
        coordinates: Coordinates,
        claimed_by: address,
        claimed_at: u64,
    ): MapIslandClaimed acquires Map {
        MapIslandClaimed {
            version: singleton_version(store_address, ),
            coordinates,
            claimed_by,
            claimed_at,
        }
    }

    struct IslandResourcesGathered has store, drop {
        version: u64,
        player_id: address,
        coordinates: Coordinates,
        resources: vector<ItemIdQuantityPair>,
        gathered_at: u64,
    }

    public fun island_resources_gathered_player_id(island_resources_gathered: &IslandResourcesGathered): address {
        island_resources_gathered.player_id
    }

    public fun island_resources_gathered_coordinates(island_resources_gathered: &IslandResourcesGathered): Coordinates {
        island_resources_gathered.coordinates
    }

    public fun island_resources_gathered_resources(island_resources_gathered: &IslandResourcesGathered): vector<ItemIdQuantityPair> {
        island_resources_gathered.resources
    }

    public fun island_resources_gathered_gathered_at(island_resources_gathered: &IslandResourcesGathered): u64 {
        island_resources_gathered.gathered_at
    }

    public(friend) fun new_island_resources_gathered(
        store_address: address,
        player_id: address,
        coordinates: Coordinates,
        resources: vector<ItemIdQuantityPair>,
        gathered_at: u64,
    ): IslandResourcesGathered acquires Map {
        IslandResourcesGathered {
            version: singleton_version(store_address, ),
            player_id,
            coordinates,
            resources,
            gathered_at,
        }
    }


    public(friend) fun update_version_and_add(store_account: &signer, map: Map) {
        map.version = map.version + 1;
        //assert!(map.version != 0, EInappropriateVersion);
        private_add_map(store_account, map);
    }

    public(friend) fun add_map(store_account: &signer, map: Map) {
        assert!(map.version == 0, EInappropriateVersion);
        private_add_map(store_account, map);
    }

    public(friend) fun remove_map(store_address: address, ): Map acquires Map {
        assert!(exists<Map>(store_address), ENotInitialized);
        move_from<Map>(store_address)
    }

    fun private_add_map(store_account: &signer, map: Map) {
        move_to(store_account, map);
    }

    public fun get_singleton_map(store_address: address, ): pass_object::PassObject<Map> acquires Map {
        let map = remove_map(store_address, );
        pass_object::new_with_address(map, store_address, )
    }

    public fun singleton_version(store_address: address, ): u64 acquires Map {
        let map = borrow_global<Map>(store_address);
        map.version
    }

    public fun set_singleton_version(store_address: address, version: u64) acquires Map {
        let map = borrow_global_mut<Map>(store_address);
        map.version = version;
    }

    public fun return_singleton_map(store_account: &signer, map_pass_obj: pass_object::PassObject<Map>) {
        let (map, store_address, ) = pass_object::extract_value_and_address(map_pass_obj);
        assert!(std::signer::address_of(store_account, ) == store_address, EMismatchedStoreAddress);
        private_add_map(store_account, map);
    }

    public(friend) fun set_all_porperties(store_address: address, ) acquires Map {
        assert!(exists<Map>(store_address), ENotInitialized);
        let map = borrow_global_mut<Map>(store_address);
        map.version = map.version + 1;
    }

    public(friend) fun drop_map(map: Map) {
        let Map {
            version: _version,
            locations,
        } = map;
        table_with_length::destroy_empty(locations);
    }

    public fun map_exists(store_address: address, ): bool {
        exists<Map>(store_address)
    }

    public(friend) fun emit_island_added(store_address: address, island_added: IslandAdded) acquires Events {
        assert!(exists<Events>(store_address), ENotInitialized);
        let events = borrow_global_mut<Events>(store_address);
        event::emit_event(&mut events.island_added_handle, island_added);
    }

    public(friend) fun emit_map_island_claimed(store_address: address, map_island_claimed: MapIslandClaimed) acquires Events {
        assert!(exists<Events>(store_address), ENotInitialized);
        let events = borrow_global_mut<Events>(store_address);
        event::emit_event(&mut events.map_island_claimed_handle, map_island_claimed);
    }

    public(friend) fun emit_island_resources_gathered(store_address: address, island_resources_gathered: IslandResourcesGathered) acquires Events {
        assert!(exists<Events>(store_address), ENotInitialized);
        let events = borrow_global_mut<Events>(store_address);
        event::emit_event(&mut events.island_resources_gathered_handle, island_resources_gathered);
    }

}
